---
{
  "title": "递归-概览",
}
---

递归是一种解决问题的有效方法，在递归过程中，函数将自身作为子例程调用。

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/20/16cac35473048a81~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

你可能想知道如何实现调用自身的函数。诀窍在于，每当递归函数调用自身时，它都会将给定的问题拆解为子问题。递归调用继续进行，直到到子问题无需进一步递归就可以解决的地步。

为了确保递归函数不会导致无限循环，它应具有以下属性：

- 一个简单的基本案例 —— 能够不使用递归来产生答案的终止方案。
- 一组规则，也称作递推关系，可将所有其他情况拆分到基本案例。

### 重复计算

一些问题使用递归考虑，思路是非常清晰的，但是却不推荐使用递归，例如下面的几个问题：

- [斐波拉契数列](/docs/algorithm/递归和循环/斐波拉契数列.html)
- [跳台阶](/docs/algorithm/递归和循环/跳台阶.html)
- [矩形覆盖](/docs/algorithm/%E9%80%92%E5%BD%92%E5%92%8C%E5%BE%AA%E7%8E%AF/%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96.html)

这几个问题使用递归都有一个共同的缺点，那就是包含大量的重复计算，如果递归层次比较深的话，直接会导致JS进程崩溃。

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/20/16cac35481e536aa~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

你可以使用`记忆化`的方法来避免重复计算，即开辟一个额外空间来存储已经计算过的值，但是这样又会浪费一定的内存空间。因此上面的问题一般会使用动态规划求解。

> 所以，在使用递归之前，一定要判断代码是否含有重复计算，如果有的话，不推荐使用递归。

递归是一种思想，而非一个类型，很多经典算法都是以递归为基础，因此这里就不再给出更多问题。

### 迭代
一般来说，能用递归解决的问题都能用迭代来解决。
- 递归的时间复杂度一般为O(n)，空间复杂度O(n)，递归调用函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度。
- 迭代的时间复杂度一般为O(n)，空间复杂度O(1)，不需要消耗栈空间。